<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Making your first Scratch Phaser 3 Game</title>
    <script src="lib/phaser.min.js"></script>
    <script src="lib/scratch_helpers.js"></script>
    <script src="lib/scratch_game.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>

<body>

    <script type="text/javascript">
        let game = new ScratchGame(800, 600);
        game.preload = preload;
        game.create = create;
        game.update = update;

        function preload() {
            this.loadImage('sky', 'assets/sky.png');
            this.loadImage('sea', 'assets/sea.jpg');
            this.loadImage('space', 'assets/space.jpg');

            this.loadImage('ground', 'assets/platform.png');
            this.loadImage('star', 'assets/star.png');
            this.loadImage('bomb', 'assets/bomb.png');
            this.loadSpritesheet('dude', 'assets/dude.png', 32, 48);
        }

        let cursors;
        let currentBack = 0;
        let backgrounds = ['sea', 'space', 'sky'];
        let sprite2;

        function create() {
            let self = this;
            console.log(this);
            this.changeBackground(backgrounds[currentBack]);

            let sprite = this.createSprite('dude', 100, 100);
            sprite.x = 400;
            sprite.direction = 45;
            sprite.size = 2;

            sprite2 = this.createSprite('dude', 200, 100);
            sprite2.direction = 45;
            sprite2.size = 2;

            sprite.visible = false;
            sprite.tag = 'player';

            //            this.test();
            cursors = game.createdGame.input.keyboard.createCursorKeys();

            let keyObject = game.createdGame.input.keyboard.addKey("W"); // Get key object
            keyObject.on("up", function (event) {
                currentBack++;
                if (currentBack >= backgrounds.length) {
                    currentBack = -1;
                    game.setBackgroundColor(0x00FFFF);
                    return;
                }
                sprite.visible = true;
                sprite.moveForward(10);
                sprite.nextCostume();
                console.log(sprite.costume);
                console.log(sprite.costumesCount);
                game.changeBackground(backgrounds[currentBack]);
            });
        }



        function update() {
            if (cursors.left.isDown) {
                console.log('left');
            }
            sprite2.x += 2;
            sprite2.y += 100;
            sprite2.y -= 100;
            sprite2.x -= 1;
        }

        //createSprite()





        /*
                let config = {
                    type: Phaser.AUTO,
                    width: 800,
                    height: 600,
                    physics: {
                        default: 'arcade',
                        arcade: {
                            gravity: { y: 200 },
                            debug: false
                        }
                    },
                    scene: {
                        preload: preload,
                        create: create,
                        update: update
                    }
                };
        
                let game = new Phaser.Game(config);*/
        let gameOver = false;
        let score = 0;

        /*        function preload() {
                    this.load.image('sky', 'assets/sky.png');
                    this.load.image('ground', 'assets/platform.png');
                    this.load.image('star', 'assets/star.png');
                    this.load.image('bomb', 'assets/bomb.png');
                    this.load.spritesheet('dude', 'assets/dude.png', { frameWidth: 32, frameHeight: 48 });
                }*/

        /*
                function create() {
                    //  A simple background for our game
                    this.add.image(400, 300, 'sky');
        
                    //  The platforms group contains the ground and the 2 ledges we can jump on
                    platforms = this.physics.add.staticGroup();
        
                    //  Here we create the ground.
                    //  Scale it to fit the width of the game (the original sprite is 400x32 in size)
                    var p = platforms.create(400, 568, 'ground');
                    platforms.create(400, 568, 'ground').setScale(2).refreshBody();
        
                    //  Now let's create some ledges
                    platforms.create(600, 400, 'ground');
                    platforms.create(50, 250, 'ground');
                    platforms.create(750, 220, 'ground');
        
                    // The player and its settings
                    player = this.physics.add.sprite(200, 250, 'dude');
                    //            player.setMass(1000);
        
        
                    //  Player physics properties. Give the little guy a slight bounce.
                    player.setBounce(0.2);
                    player.setCollideWorldBounds(true);
                    player.setFrame(4);
        
                    //  Input Events
                    cursors = this.input.keyboard.createCursorKeys();
        
        
                    //  Our player animations, turning, walking left and walking right.
                    this.anims.create({
                        key: 'left',
                        frames: this.anims.generateFrameNumbers('dude', { start: 0, end: 3 }),
                        frameRate: 10,
                        repeat: -1
                    });
        
                    this.anims.create({
                        key: 'turn',
                        frames: [{ key: 'dude', frame: 4 }],
                        frameRate: 20
                    });
        
                    this.anims.create({
                        key: 'right',
                        frames: this.anims.generateFrameNumbers('dude', { start: 5, end: 8 }),
                        frameRate: 10,
                        repeat: -1
                    });
        
                    //  Some stars to collect, 12 in total, evenly spaced 70 pixels apart along the x axis
                    stars = this.physics.add.group({
                        key: 'star',
                        repeat: 11,
                        setXY: { x: 12, y: 0, stepX: 70 }
                    });
        
                    stars.children.iterate(function (child) {
        
                        //  Give each star a slightly different bounce
                        child.setBounceY(Phaser.Math.FloatBetween(0.4, 0.8));
                        //                child.body.setCircle(10);
        
                    });
        
                    bombs = this.physics.add.group();
        
                    //  The score
                    scoreText = this.add.text(16, 16, 'score: 0', { fontSize: '32px', fill: '#000' });
        
                    //  Collide the player and the stars with the platforms
                    this.physics.add.collider(player, platforms);
                    this.physics.add.collider(stars, platforms);
                    this.physics.add.collider(bombs, platforms);
        
                    //  Checks to see if the player overlaps with any of the stars, if he does call the collectStar function
                    this.physics.add.overlap(player, stars, collectStar, checkPixelPerfect, this);
        
                    this.physics.add.collider(player, bombs, hitBomb, null, this);
        
                    this.physics.add.collider(player, platforms);
                }
        
                function update() {
                    if (gameOver) {
                        return;
                    }
        
                    if (cursors.left.isDown) {
                        player.setVelocityX(-160);
        
                        player.anims.play('left', true);
                    }
                    else if (cursors.right.isDown) {
                        player.setVelocityX(160);
        
                        player.anims.play('right', true);
                    }
                    else if (player.body.touching.down) {
                        player.setVelocityX(0);
        
                        player.anims.play('turn');
                    }
        
                    if (cursors.up.isDown && player.body.touching.down) {
                        player.setVelocityY(-330);
                    }
                }*/

        function collectStar(player, star) {
            star.disableBody(true, true);

            //  Add and update the score
            score += 10;
            scoreText.setText('Score: ' + score);

            if (stars.countActive(true) === 0) {
                //  A new batch of stars to collect
                stars.children.iterate(function (child) {

                    child.enableBody(true, child.x, 0, true, true);

                });

                var x = (player.x < 400) ? Phaser.Math.Between(400, 800) : Phaser.Math.Between(0, 400);

                var bomb = bombs.create(x, 16, 'bomb');
                bomb.setBounce(1);
                bomb.setCollideWorldBounds(true);
                bomb.setVelocity(Phaser.Math.Between(-200, 200), 20);
                bomb.allowGravity = false;

            }
        }

        function hitBomb(player, bomb) {
            this.physics.pause();

            player.setTint(0xff0000);

            player.anims.play('turn');

            gameOver = true;
        }

        function checkPixelPerfect(obj1, obj2) {
            var bounds1 = obj1.getBounds();
            var bounds2 = obj2.getBounds();

            var intersection = Phaser.Geom.Rectangle.Intersection(bounds1, bounds2);

            if (intersection.isEmpty()) {
                return false;
            }

            var pixelAlpha1, pixelAlpha2;

            for (var y = intersection.y; y < intersection.bottom; y++) {
                for (var x = intersection.x; x < intersection.right; x++) {
                    pixelAlpha1 = getPixelAlpha(obj1, x, y);
                    if (pixelAlpha1 <= 200) {
                        continue;
                    }

                    pixelAlpha2 = getPixelAlpha(obj2, x, y);

                    if (pixelAlpha2 > 200) {
                        return true;
                    }
                }
            }
            return false;
        }

        function getPixelAlpha(obj, x, y) {
            // Transform world coordinates to local coordinates taking rotation into account
            var dx = x - obj.x;
            var dy = y - obj.y;

            var rotation = -obj.rotation;
            var cos = Math.cos(rotation);
            var sin = Math.sin(rotation);

            var rx = dx * cos - dy * sin;
            var ry = dx * sin + dy * cos;

            var localX = Math.floor(rx / obj.scaleX + obj.displayOriginX);
            var localY = Math.floor(ry / obj.scaleY + obj.displayOriginY);

            if (obj.flipX) {
                localX = obj.frame.width - 1 - localX;
            }
            if (obj.flipY) {
                localY = obj.frame.height - 1 - localY;
            }

            if (localX < 0 || localX >= obj.frame.width || localY < 0 || localY >= obj.frame.height) {
                return 0;
            }

            var pixel = game.textures.getPixelAlpha(localX, localY, obj.texture.key, obj.frame.name);

            return (pixel === null) ? 0 : pixel;
        }

    </script>

</body>

</html>